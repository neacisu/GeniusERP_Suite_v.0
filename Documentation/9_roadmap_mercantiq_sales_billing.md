# 9 · Roadmap Mercantiq Sales & Billing (F2) — Order-to-Cash + POS

**Scop:** Livrarea aplicației stand-alone **Mercantiq Sales & Billing** pentru gestionarea proceselor de vânzare (POS) și facturare în ecosistemul GeniusERP Suite. Modulul acoperă fluxul complet Order-to-Cash – de la preluarea comenzilor de vânzare și emiterea facturilor fiscale (inclusiv e-Factura conform ANAF) până la înregistrarea plăților. Include și un modul POS optimizat pentru retail cu suport offline.

## Cum să folosești această documentație

Această documentație reprezintă un roadmap detaliat pentru dezvoltarea aplicației stand-alone Mercantiq Sales & Billing (Order-to-Cash + POS). Lista de pași este organizată sub formă de obiecte JSON, fiecare element corespunzând unei etape concrete de implementare. Iată câteva sfaturi pentru a utiliza eficient această documentație:

**Parcurge pașii în ordine:** Fiecare element JSON are un câmp step (indexul pasului) și descrie o acțiune ce trebuie realizată. Este recomandat să se abordeze aceste task-uri sequential, deoarece unele depind de livrările anterioare (indicate în câmpul context).

**Înțelege structura câmpurilor:** Fiecare obiect conține câmpuri esențiale – scope indică sub-sistemul sau componenta vizată, context oferă detalii despre starea proiectului înainte de acest pas, task descrie în mod imperativ acțiunea de efectuat, dirs precizează directoarele/proiectele afectate, constraints enumeră reguli sau condiții ce trebuie respectate (ex.: convenții de commit, limite de performanță, stil de cod), iar output descrie pe scurt rezultatul așteptat în urma implementării.

**Respectă constraints:** Câmpul constraints include cerințe stricte precum respectarea convențiilor de commit (ex. Conventional Commits), rularea linter-elor, evitarea includerii secretelor în cod, sau condiții de performanță și securitate. Asigură-te că la finalul fiecărui pas aceste condiții sunt îndeplinite (pipeline-urile CI/CD vor verifica multe dintre ele automat).

**Verifică output-ul așteptat:** După ce implementezi un pas, compară rezultatul cu descrierea din output. Acesta oferă un indiciu dacă implementarea ta a atins obiectivul (de ex. un test care trece, un modul generat, o funcționalitate vizibilă în UI sau metrici expuse în sistemul de monitorizare).

**Navighează după scope:** Pașii sunt grupați logic prin câmpul scope (ex. "sales-…", "pos-…", "invoice-…", "backend-…"). Poți prioritiza sau delega anumite sub-sisteme pe baza acestei clasificări, dacă lucrează mai mulți dezvoltatori în paralel.

**Precondiții și context:** Documentația presupune că Gate-ul F1 (faza anterioară) a fost trecut cu succes (ex. shell-ul aplicației este funcțional, modulul Admin-Core și Worker Registry sunt în starea dorită). Astfel, pașii de față (F2) se concentrează pe modulul Mercantiq Sales & Billing și integrarea sa cu restul platformei.

După ce ai parcurs întregul roadmap, modulul Mercantiq Sales & Billing ar trebui să fie complet implementat, integrat și gata de testare end-to-end în ecosistemul Genius ERP.

## 1) Pre‑condiții & Scope

* **Gate F1 trecut**: Shell vizibil (3 widget‑uri), Admin Core & Worker Registry verzi.
* **Event‑Bus v1** și naming `<module>.<ctx>.<event>` deja stabilite; hook `scripts/lint-rmq.sh` obligatoriu.
* **Multitenancy & date**: PostgreSQL 17 (cluster per tenant, schema per modul), MinIO per tenant, Redis per tenant, **RLS pe `tid/whid/mid`**.
* **Worker Fleet** disponibil: `pdf.render`, `tax.vat`, `notify.slack`.
* **Stack fix**: React 19 + Vite 5 Federation + MUI 6 + Tailwind 3 (UI), NestJS 11 (API), Python 3.13 (workeri), RabbitMQ 3.14 + Redis 7 (bus/queue), IaC: Terraform + Helmfile + Argo CD.

## 2) Bounded‑Context & Interfețe

### **Entități principale**
* **Customers**: clienți pentru comenzi și facturare
* **Products**: produse cu prețuri în liste configurabile  
* **SalesOrders**: comenzi de vânzare cu linii detaliate
* **Invoices**: facturi emise pentru comenzi livrate
* **Payments**: plăți înregistrate pentru facturi

### **Evenimente publicate**
* **`sales.order.created`**: comandă nouă plasată
* **`sales.invoice.issued`**: factură emisă după livrare
* **`payment.received`**: plată înregistrată pentru factură

### **Evenimente consumate**
* **`wms.picklist.completed`**: trigger pentru generare factură
* **`tax.vat.validated`**: confirmare validare ANAF
* **`pdf.render.done`**: PDF factură finalizat

## 3) Arhitectura Aplicației

### **Mercantiq Sales & Billing Overview**

Mercantiq Sales & Billing este aplicația responsabilă de gestionarea proceselor de vânzare (POS) și facturare în GeniusERP Suite, integrându-se strâns cu celelalte module comerciale din Faza F2. Scopul acestui modul este să permită fluxul complet Order‑to‑Cash – de la preluarea comenzilor de vânzare și emiterea facturilor fiscale (inclusiv e-Factura conform ANAF) până la înregistrarea plăților – asigurând totodată conformitatea locală și integrarea cu sistemele adiacente (CRM, WMS, Workers).

### **Integrarea cu Ecosistemul**

Prin Mercantiq Sales, oportunitățile câștigate în modulul CRM (Vettify) devin comenzi de vânzare, iar livrarea acestora este urmărită prin WMS (iWMS v3) – la finalizarea picklist-ului de livrare (`wms.picklist.completed`), Mercantiq Sales generează factura aferentă și o emite atât intern (PDF) cât și către sistemul național e-Factură. 

Validarea codului fiscal și conformitatea facturii sunt asigurate de worker-ul `tax.vat`, iar generarea PDF-ului semnat electronic de worker-ul `pdf.render` (cu stocare securizată în MinIO, criptare SSE‑C cu cheie unică per chiriaș).

### **Modulul POS (Point-of-Sale)**

Aplicația oferă și un modul POS pentru vânzări rapide în retail, optimizat pentru utilizare offline (cache local al tranzacțiilor și retransmitere automată la restabilirea conexiunii). Interfața POS permite înregistrarea rapidă a vânzărilor (scan produs, selectare client, emitere bon/factură, încasare cash/card) chiar și în absența temporară a rețelei, asigurând sincronizarea datelor la reconectare.

## 4) Securitate & RBAC

* Scopes Keycloak `sales/*` pentru toate operațiunile de vânzare și facturare
* Guard JWT + RLS pe toate tabelele pentru izolare multi-tenant
* ABAC la UI (ascunde funcții pentru roluri nepermise)
* Integrare cu Admin Core pentru teme UI și navigație

## 5) Observabilitate

* OTel traces frontend→API→worker pentru flux complet O2C
* Prometheus HTTP metrics + business metrics (comenzi, facturi, plăți)
* Dashboard dedicat Order-to-Cash în Grafana cu SLO monitoring
* Alerting pentru rate de eroare >1% și latență p95 >250ms

## 6) Criterii de Acceptanță F2

* **Flux O2C complet**: comandă → factură → plată în <3 minute
* **Conformitate ANAF**: e-Factură validată și emisă
* **Performance**: API p95 <250ms, error rate <1%
* **POS offline**: funcțional fără conexiune cu sync automat
* **Integrare**: evenimente publicate/consumate conform specificației

## 7) Structura Implementării

### **Interval F2**: 2-2 (3 SW)
- **Effort**: 3 săptămâni dezvoltare
- **Scop**: Mercantiq Sales & Billing MVP cu POS și integrare workers
- **Modul**: `mercantiq-sales` (frontend + api)
- **Dependențe**: F1 Core Platform + F2 Base Workers

---

## 8) CursorAI Prompts (Mercantiq Sales & Billing 320–359)

```json
[
  {
    "step": 320,
    "scope": "sales-scaffold",
    "context": "Modul inexistent; structura monorepo Nx creată în F0/F1",
    "task": "Generează scheletul aplicației Mercantiq Sales & Billing: proiect Nx frontend (React+Vite) și API (NestJS) sub `standalone/mercantiq/apps/sales/`. Include configurare inițială Module Federation (remote) și stub de modul NestJS.",
    "dirs": [
      "/standalone/mercantiq/apps/sales/frontend/",
      "/standalone/mercantiq/apps/sales/api/"
    ],
    "constraints": "folosește `scripts/create-module.ts --standalone mercantiq-sales`; tags Nx `module:mercantiq-sales, layer:frontend/api`; commit 'feat(mercantiq-sales): scaffold module'.",
    "output": "skeleton Mercantiq Sales & Billing generat și configurat"
  },
  {
    "step": 321,
    "scope": "sales-db-schema",
    "context": "Schema DB separată per modul (multitenancy); niciun tabel Sales încă definit",
    "task": "Definește modelul de date și creează migration inițial pentru entitățile principale: `customers`, `products`, `price_lists` (inclusiv itemi preț produs), `sales_orders` + `sales_order_lines`, `invoices`, `payments`. Adaugă coloane `tid` și `whid` pe fiecare tabel pentru izolarea datelor multi-chiriaș.",
    "dirs": [
      "/standalone/mercantiq/apps/sales/api/src/migrations/"
    ],
    "constraints": "Utilizează tipuri adecvate (ex: UUID primary keys, numeric pentru prețuri); definește FK stricte între tabele (ex: `sales_order_lines.sales_order_id -> sales_orders.id` etc.); RLS activ pe `tid, whid` (policy SELECT/INSERT/UPDATE/DELETE). Commit 'feat(sales-db): initial schema'.",
    "output": "tabele Sales & Billing create cu RLS și relații definite"
  },
  {
    "step": 322,
    "scope": "sales-db-seed",
    "context": "Scheme create la pasul 321; niciun datum demo",
    "task": "Populează date de bază pentru dezvoltare/test: inserează prin migration sau script seed un set de bază – ex. 1 client demo (ACME Corp), 3 produse (cu prețuri în lista implicită \"Standard\"). Asigură-te că există o listă de preț implicită și intrări corespunzătoare în `price_list_items`.",
    "dirs": [
      "/standalone/mercantiq/apps/sales/api/src/migrations/",
      "/standalone/mercantiq/apps/sales/api/src/seed/"
    ],
    "constraints": "Fără secrete hardcodate; datele demo marcate cu `tenant_id` specific (demo). Commit 'feat(sales-db): add seed data F2'.",
    "output": "date demo Sales inserate (client demo + 3 produse cu prețuri)"
  },
  {"step":323,"scope":"sales-security","context":"Autentificare JWT globală (Keycloak) disponibilă; guard generat în Admin Core (pasul 231 F1)","task":"Configurează securitatea modulului Sales: aplică **JWT Auth Guard** la toate controller-ele NestJS și asigură extragerea `tenantId` din token pentru a seta contextul DB (ex: folosește un middleware sau interceptor pentru a executa `SET app.tid = <tid>` pe conexiune Postgres, astfel încât politicile RLS pe `tid`/`whid` să fie eficiente). Definește scopes/roluri specifice (ex: `sales.read/sales.write`); restrictționează acțiunile critice (ex: creare produs, modificare preț) la roluri de administrator Sales.","dirs":["/standalone/mercantiq/apps/sales/api/src/","/standalone/mercantiq/apps/sales/api/src/guards/"],"constraints":"Reutilizează mecanismele existente (ex: guardul JWT din Admin Core extins pentru scopes); nu duplică cod. Testează cu un JWT valid că accesul la endpoint-uri neautentificate este refuzat (HTTP 401).","output":"endpoints protejate cu JWT & RBAC (tenant isolation activ)"},
  {"step":324,"scope":"customer-api","context":"Tabelă `customers` disponibilă (pas 321); securitate configurată (pas 323)","task":"Implementează CRUD pentru entitatea **Customer**: serviciu NestJS `CustomerService` și controller `CustomerController` cu endpoint-uri `GET /customers` (listare clienți pe tenant, paginat), `POST /customers` (adăugare client nou), `PUT /customers/:id` (editare) și `DELETE /customers/:id`. Utilizează DTO cu `class-validator` pentru validarea câmpurilor (ex: `name` obligatoriu, format CUI valid opțional).","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/dto/"],"constraints":"Endpoint-urile protejate de guard (ex: require scope `sales.write` pentru POST/PUT/DELETE); teste unitare pentru service (≥80% coverage). Commit 'feat(sales-api): customer endpoints'.","output":"API Customers disponibil (CRUD complet cu validări și teste)"},
  {"step":325,"scope":"product-api","context":"Tabelă `products` și relație cu `price_lists` definite (pas 321)","task":"Implementează serviciul și controller-ul pentru **Product**: `ProductService` și `ProductController`. Endpoint-uri: `GET /products` (listare produse cu preț curent din lista de preț implicită), `POST /products` (creare produs nou, cu detalii ca nume, SKU, unitate măsură, etc. și adăugare preț în lista implicită), `PUT /products/:id` (actualizare produs sau preț implicit), `DELETE /products/:id`. La listare, include și prețul (join cu `price_list_items`).","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/entities/"],"constraints":"Validează datele (ex: `price` >= 0); la creare produs, asociază-l automat la lista de preț implicită cu prețul furnizat. Commit 'feat(sales-api): product endpoints'.","output":"API Products disponibil (produse + prețuri cu validări complete)"},
  {"step":326,"scope":"salesorder-api","context":"Tabele `sales_orders` și `sales_order_lines` migrate (pas 321); entități Product/Customer disponibile","task":"Implementează logica de comandă de vânzare: serviciul `SalesOrderService` și controller-ul `SalesOrderController`. Endpoint-uri: `POST /sales-orders` pentru creare comandă nouă (body include clientId, array de linii {productId, quantity}), `GET /sales-orders` (listare comenzi filtrate implicit pe tenant și eventual după status), `GET /sales-orders/:id` (detalii comandă, inclusiv linii și status). La creare, calculează subtotal și total (pe baza prețurilor din lista selectată, implicit Standard), setează status inițial \"New\" și salvează atât comanda cât și liniile aferente.","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/entities/"],"constraints":"Validează: client existent, produse existente, cantități >0. Utilizează tranzacție DB pentru inserarea master-detail (SO + linii). Dacă o linie referă un product fără preț în lista curentă, returnează 400. Commit 'feat(sales-api): sales order create/list'.","output":"API SalesOrders permite creare și listare comenzi (calcul total automat, validări complete)"},
  {"step":327,"scope":"salesorder-events","context":"Comandă creată prin API (pas 326); Event Bus v1 disponibil (F1)","task":"Publică un eveniment business **`sales.order.created`** imediat după ce o comandă de vânzare este salvată cu succes. Include în payload detalii relevante (ex: orderId, customerId, total, etc.). Asigură integrarea cu Event Bus: folosește SDK-ul TS (ex: EventBusClient) sau RabbitMQ directly pentru publish. Implementează eventual un test (contract-test) care verifică publicarea evenimentului la crearea unei comenzi noi.","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/events/"],"constraints":"Respectă convenția de naming v1 (topic `sales.order.created`); nu dubla evenimentul (publish o singură dată după commit DB). Commit 'feat(sales-events): publish sales.order.created'.","output":"eveniment `sales.order.created` publicat pe bus la creare comandă (payload validat, contract test trecut)"},
  {"step":328,"scope":"invoice-service","context":"Tabelă `invoices` disponibilă (pas 321); comandă de vânzare deja creată","task":"Implementează **InvoiceService** în NestJS pentru generarea facturilor. Include logica de a crea o factură pe baza unei comenzi date: copiere date client, linii (produse, cantități, prețuri unitare, taxe) și calcul total factură. Setează status inițial \"Pending\" și asociază facturii ID-ul comenzii sursă. Creează și un controller `InvoiceController` cu cel puțin endpoint-ul `GET /invoices/:id` (vizualizare factură) și, opțional, `POST /sales-orders/:id/invoice` pentru a genera manual factura unei comenzi (ca alternativă la fluxul automat pe eveniment).","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/entities/"],"constraints":"Asigură consistența: o comandă nu produce decât o singură factură (previne duplicare dacă endpoint-ul manual este apelat de două ori sau și evenimentul WMS creează automat). Validează existența comenzii și că nu e deja facturată. Commit 'feat(sales-api): invoice service'.","output":"serviciu & controller Invoice implementate (generare factură din comandă, prevenire duplicate)"},
  {"step":329,"scope":"wms-event-consume","context":"Comanda marcată \"livrată\" în iWMS (eveniment extern)","task":"Integrează consumul evenimentului **`wms.picklist.completed`** în modulul Sales. Configurează un subscriber (ex: folosind SDK-ul RabbitMQ sau microservice Nest) care ascultă acest topic. La primirea evenimentului, verifică `orderId`/referința comenzii din payload și apelează InvoiceService pentru a genera factura corespunzătoare acelei comenzi (dacă nu există deja). Actualizează statusul comenzii la \"Delivered\". După salvarea facturii, publică evenimentul **`sales.invoice.issued`** (conține invoiceId, orderId, total, etc.).","dirs":["/standalone/mercantiq/apps/sales/api/src/events/","/standalone/mercantiq/apps/sales/api/src/services/"],"constraints":"Consumatorul trebuie să fie **idempotent** (în caz de re-emitere eveniment de către WMS, să nu creeze duplicat de factură). Marchează factura ca emisă (status=Issued) și atașează timestamp. Commit 'feat(sales-events): handle wms.picklist.completed'.","output":"eveniment WMS consumat și factură generată automat + `sales.invoice.issued` publicat (procesare idempotentă)"},
  {"step":330,"scope":"tax-vat-integration","context":"Eveniment `sales.invoice.issued` publicat (pas 329); worker `tax.vat` disponibil în flotă","task":"Integrează verificarea automată a facturilor prin worker-ul **`tax.vat`** (validare TVA/e-Factura). La emiterea fiecărei facturi, asigură-te că aceasta declanșează procesul de validare: de ex., `tax.vat` ar putea fi declanșat indirect prin faptul că ascultă evenimentul `sales.invoice.issued` sau prin trimiterea explicită a unui mesaj/task la coada dedicată. Implementează logica de recepționare a rezultatului: creează un subscriber pentru evenimentul **`tax.vat.validated`** (emis de worker după validare). Când este primit, actualizează înregistrarea facturii: ex. setează câmp `validated=true` și salvează codul de confirmare/numărul e-Factură primit (dacă există).","dirs":["/standalone/mercantiq/apps/sales/api/src/events/","/standalone/mercantiq/apps/sales/api/src/services/"],"constraints":"Nu include chei API sau credențiale ANAF în cod – acestea trebuie preluate din mediu securizat (ExternalSecrets). Asigură tratament pentru facturi marcate ca invalid (ex: câmp `errors` dacă workerul returnează erori).","output":"facturile emise sunt trimise spre validare ANAF (tax.vat); status valid/invalid actualizat cu cod confirmare"},
  {"step":331,"scope":"invoice-pdf-generate","context":"Worker `pdf.render` disponibil (HTML→PDF); factură emisă în sistem (pas 329)","task":"Permite generarea PDF pentru facturi. Implementează în `InvoiceController` un endpoint `POST /invoices/:id/pdf` care, la apel, pregătește un payload (ex: HTML sau JSON cu date factură) și publică o cerere către worker-ul **`pdf.render`** (ex: push mesaj în coada `pdf.render`). Înregistrează în baza de date faptul că factura este în curs de randare (ex: `pdf_status='processing'`).","dirs":["/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/services/"],"constraints":"Asigură-te că payload-ul conține tot ce e necesar pentru PDF (sau un endpoint de unde workerul poate prelua datele). Nu bloca cererea HTTP până la finalizarea PDF – răspunde async (202 Accepted). Commit 'feat(sales-api): request invoice PDF'.","output":"endpoint PDF generation implementat (req. trimisă la worker, status processing setat)"},
  {"step":332,"scope":"invoice-pdf-complete","context":"Cerere PDF trimisă la worker (pas 331)","task":"Integrează răspunsul asincron al worker-ului **`pdf.render`**. Configurează subscriber pentru evenimentul **`pdf.render.done`** (emis de worker la finalizare). La primire, identifică factura aferentă (ex: prin invoiceId în payload) și preia fișierul PDF generat. Stochează fișierul în MinIO (bucket tenant specific) cu **SSE-C** activ (cheie de criptare din Vault) și salvează în baza de date un link sau path către PDF (ex: `invoice.pdf_path`). Actualizează statusul PDF la \"ready\".","dirs":["/standalone/mercantiq/apps/sales/api/src/events/","/standalone/mercantiq/apps/sales/api/src/services/"],"constraints":"Verifică integritatea fișierului (ex: dimensiune >0). Folosește SDK MinIO sau API S3 cu header-ul de criptare. Șterge fișierele temporare dacă e cazul. Commit 'feat(sales-events): handle pdf.render.done'.","output":"factura marcată cu PDF generat (path salvat în DB, stocare MinIO cu SSE-C)"},
  {"step":333,"scope":"invoice-pdf-download","context":"PDF-ul facturii stocat în MinIO (pas 332); nevoie de acces client","task":"Expune posibilitatea de descărcare a facturii în format PDF. Implementează în `InvoiceController` endpoint-ul `GET /invoices/:id/pdf` care servește fișierul PDF clientului autenticat. Realizează fetch din MinIO (folosind cheia de criptare corespunzătoare tenant-ului) și transmite fișierul ca răspuns `application/pdf` (atașament). Alternativ, generează un URL semnat temporar (presigned URL) pentru descărcare și returnează-l ca locație.","dirs":["/standalone/mercantiq/apps/sales/api/src/controllers/"],"constraints":"Asigură-te că doar tenant-ul proprietar poate descărca (verifică `tid` din JWT vs. tenant-ul facturii). Dacă PDF nu e încă generat, returnează 404 sau 202 Accept dacă implementăm pooling. Test: un user din alt tenant primește 403.","output":"endpoint download PDF funcțional și securizat (verificare tenant, headers corecte)"},
  {"step":334,"scope":"payment-api","context":"Tabelă `payments` disponibilă (pas 321); factură emisă ce trebuie încasată","task":"Implementează logica de înregistrare plăți: serviciul `PaymentService` și controller-ul `PaymentController`. Endpoint `POST /payments` (sau în contextul facturii: `POST /invoices/:id/payments`) care înregistrează o plată nouă (specifică invoiceId, sumă, metodă – ex. cash sau card, data). La creare, actualizează statusul facturii la \"Paid\" dacă suma acoperă totalul. Endpoint `GET /payments` (listare plăți recente, poate filtrat pe client sau perioadă) nu este prioritar, dar poate fi adăugat pentru audit.","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/controllers/","/standalone/mercantiq/apps/sales/api/src/entities/"],"constraints":"Validează: factura există și aparține tenant-ului; suma >0; nu permite dublarea plății (dacă deja plătită integral). Commit 'feat(sales-api): payment record'.","output":"API Payments disponibil (înregistrare plată cu validări, actualizare status factură)"},
  {"step":335,"scope":"payment-events","context":"Plată înregistrată prin API (pas 334)","task":"Publică evenimentul **`payment.received`** de fiecare dată când o nouă plată este înregistrată cu succes. Include în payload cel puțin paymentId, invoiceId și amount. Acest eveniment va fi folosit pentru a notifica alte subsisteme (ex: Accounting în F3, notificări Slack). Asigură-te că evenimentul este emis după commit DB.","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/standalone/mercantiq/apps/sales/api/src/events/"],"constraints":"Respectă formatul convenit (nume modul.prefix, past tense). Dacă apar erori la salvare plată, nu emite eveniment. Testează cu o plată dummy că eventul apare în bus (event viewer).","output":"eveniment `payment.received` publicat la încasare (payload validat, timing după commit)"},
  {"step":336,"scope":"slack-integration","context":"Worker `notify.slack` disponibil (pas 281 F1) pentru notificări","task":"Integrează notificările Slack pentru evenimentele importante din modulul Sales. De exemplu, la primirea evenimentului `payment.received` sau imediat după înregistrarea unei plăți, trimite o notificare pe un canal Slack (ex: \"Invoice #XYZ has been paid\"). Utilizează worker-ul **`notify.slack`**: de preferat, publică un job în coada `notify.slack` cu detaliile mesajului (sau folosește un webhook preconfigurat prin worker). Asigură-te că URL-ul webhook Slack este injectat via secret extern (nu în cod).","dirs":["/standalone/mercantiq/apps/sales/api/src/services/","/apps/workers-core/notify-slack/"],"constraints":"Format mesaj clar (incluzând referințe la client și sumă). Nu bloca thread-ul API; trimiterea este asincronă. Verifică în logs că workerul Slack preia și livrează mesajul.","output":"notificare Slack trimisă la evenimentele de plată (mesaj formatat, livrare confirmată în logs)"},
  {"step":337,"scope":"sales-frontend-init","context":"Frontend Mercantiq Sales generat (pas 320) dar neconfigurat","task":"Configurează proiectul frontend **Mercantiq Sales** pentru a funcționa ca microfrontend remote. Adaugă în `vite.config.ts` setările de Module Federation: un remoteName unic (ex: `mercantiq_sales`) și expune modulul principal al aplicației. Configurează `index.html` cu elementul script remote și asigură că build-ul produce `remoteEntry.js`. Actualizează `tsconfig.json` cu aliasuri relevante (dacă folosește pachete comune, ex: `@genius/ui`).","dirs":["/standalone/mercantiq/apps/sales/frontend/"],"constraints":"Respectă convențiile din Shell (pas 203 F1) pentru remote loader. Fără path absolut în importuri. Commit 'chore(sales-ui): configure module federation'.","output":"frontend Mercantiq Sales configurat ca remote module (remoteEntry.js generat)"},
  {"step":338,"scope":"sales-frontend-theming","context":"Design tokens globali disponibili (`@genius/ui`); Tailwind instalat la nivel monorepo","task":"Configurează **Tailwind CSS** și tema Material-UI în aplicația frontend Sales. Creează `tailwind.config.js` specific modulului dacă e necesar, importă presetul de tokeni (culori, fonturi) folosit de suite. Inițializează MUI ThemeProvider la nivelul aplicației Sales, utilizând tema din Admin Core (ex: poate fi preluată via context sau API /admin/themes dacă disponibil). Asigură compatibilitate cu switch dark/light global.","dirs":["/standalone/mercantiq/apps/sales/frontend/src/","/standalone/mercantiq/apps/sales/frontend/"],"constraints":"Important: folosește `@mui/material` v6 conform suitei; asigură că Tailwind clasele funcționează (ex: `important: '#root'` dacă e necesar în config). Commit 'feat(sales-ui): add theme & tailwind'.","output":"stilizare Sales UI aliniată la tema globală (dark/light switch funcțional)"},
  {"step":339,"scope":"pos-ui","context":"Necesitate interfață POS (scenariu retail)","task":"Implementează componenta principală **POS Terminal** în frontend-ul Sales. Creează o pagină sau view `PosTerminalPage` ce conține: listă de produse (pentru scanare/selecție rapidă), coșul curent (produse selectate, cantități, total), câmp de selectare client (dropdown sau search pentru Customer) și buton de finalizare vânzare (plată cash sau card). Simulează scanarea produselor prin introducerea codului (sau selectarea din listă). La finalizare, apelează API-ul: `POST /sales-orders` pentru a crea comanda și apoi `POST /payments` pentru a înregistra plata (dacă modul POS presupune plată imediată).","dirs":["/standalone/mercantiq/apps/sales/frontend/src/pages/","/standalone/mercantiq/apps/sales/frontend/src/components/pos/"],"constraints":"Optimizează UX pentru viteză: focus automat pe input cod produs, suport pentru cititor cod bare (input events). Nu implementa flux complex de factură aici (presupunem că facturarea e implicită la POS prin bon fiscal separat eventual). Vitest: adaugă teste la componenta de calcul total (80%+ cov).","output":"UI POS terminal implementată (vânzare rapidă funcțională, suport scan cod bare, calcul total automat)"},
  {"step":340,"scope":"pos-offline-cache","context":"POS Terminal implementat (pas 339); requirement offline","task":"Adaugă suport **offline** pentru POS: la plasarea unei comenzi dacă rețeaua este indisponibilă (detectat via Navigator API sau eșec fetch), salvează tranzacția local (ex: în `localStorage` sau IndexedDB) într-o coadă offline. Implementează un utilitar `OfflineOrderQueue` care stochează cererile (endpoint + payload) și un mecanism de identificare unică (ex: un UUID temporar pentru comandă). Notifică vizual utilizatorul (ex: un banner "Offline mode – order saved locally").","dirs":["/standalone/mercantiq/apps/sales/frontend/src/utils/","/standalone/mercantiq/apps/sales/frontend/src/components/"],"constraints":"Nu pierde datele la refresh – folosește un storage persistent (IndexedDB preferabil pentru volum). Asigură că datele sensibile (ex: detalii plată) sunt minime în stocare locală. Testează scenariul: dezactivează conexiunea și înregistrează o comandă, verifică că este reținută local.","output":"comenzi POS tamponate offline când nu e conexiune (IndexedDB persistent, notificare vizuală)"},
  {"step":341,"scope":"pos-offline-sync","context":"Comenzi offline în coadă locală (pas 340); conexiune restabilită","task":"Implementează mecanismul de **resync**: la recăpătarea conexiunii (detectare `online` event în browser), parcurge coada locală de comenzi nesincronizate și trimite fiecare cerere către API-ul backend. Menține ordinea originală a tranzacțiilor. Pentru fiecare reușită, elimină din coadă și notifică utilizatorul (ex: "Order #TEMP123 synced"). Dacă o cerere eșuează (ex: eroare server), păstreaz-o în coadă și încearcă din nou mai târziu, evitând blocarea întregii cozi.","dirs":["/standalone/mercantiq/apps/sales/frontend/src/utils/"],"constraints":"Folosește API-urile Browser (event listener pentru `window.online`). Implementează backoff la retry dacă serverul rămâne indisponibil. Loghează sincronizările pentru debugging (doar în dev console).","output":"comenzile offline sunt automat transmise la server la reconectare (retry cu backoff, notificări utilizator)"},
  {"step":342,"scope":"orders-ui","context":"API SalesOrders listare disponibil (pas 326); UI POS funcțional","task":"Creează o pagină **Order Management** în frontend pentru a vizualiza comenzile și facturile. Implementează componenta `SalesOrdersPage` cu tabel de comenzi: coloane pentru ID, Client, Data, Total, Status (ex: New/Delivered/Invoiced/Paid). Permite filtrare după status. Dacă o comandă are factură emisă, evidențiază acest lucru și oferă opțiunea de a descărca factura (buton/link). Folosește API-ul `/sales-orders` (GET) pentru a popula lista.","dirs":["/standalone/mercantiq/apps/sales/frontend/src/pages/","/standalone/mercantiq/apps/sales/frontend/src/components/orders/"],"constraints":"Paginated fetch (dacă >50 comenzi). Utilizează biblioteca de UI (ex: MUI DataGrid) pentru sortare/filtrare client-side. Integrează în meniul modulului Sales (navigare între POS și Orders).","output":"pagina de listare comenzi implementată (tabel paginat, filtrare status, download factură)"},
  {"step":343,"scope":"invoice-download-ui","context":"Endpoint download PDF disponibil (pas 333); pagina Orders cu date factură","task":"Adaugă funcționalitate de descărcare factură PDF din UI. În tabelul de comenzi (pagina Order Management), dacă statusul comenzii este 'Invoiced' sau 'Paid' și există un `pdf_path` pentru factură, afișează un buton \"Download Invoice\" pe rând. La click, fie descarcă direct folosind `GET /invoices/:id/pdf`, fie redirecționează browser-ul către URL-ul presigned primit de la server. Asigură-te că în timpul descărcării se afișează un indicator de încărcare.","dirs":["/standalone/mercantiq/apps/sales/frontend/src/components/orders/"],"constraints":"Protejează acțiunea – doar utilizatori autentificați pot descărca (browserul va include JWT oricum). Gestionează erorile (ex: dacă încă nu e generat PDF-ul, arată mesaj).","output":"buton Download Invoice funcțional în UI (PDF descărcat cu loading indicator, gestionare erori)"},
  {"step":344,"scope":"backend-unit-tests","context":"Servicii backend create (Customer, Order, Invoice etc.)","task":"Scrie teste unitare cu Jest pentru logica de business critică din backend. Exemple: test pentru `SalesOrderService.createOrder` (îi dai un payload de produse și verifici că returnează totalul corect și salvează în DB), test pentru `InvoiceService.issueInvoice` (cu o comandă dummy, verifici că creează factura și calculează totalul identic). Mock-uiește accesul la DB (folosind TypeORM in-memory sau un repository fake) și dependențele exterioare (ex: EventBusClient). Atinge acoperire minim 85%.","dirs":["/standalone/mercantiq/apps/sales/api/src/services/__tests__/"],"constraints":"Include cazuri de eroare (ex: createOrder cu productID inexistent aruncă excepție). Rulează testele în CI. Commit 'test(sales-api): add unit tests'.","output":"teste unitare backend verzi (coverage >85%, mock-uri DB și evenimente)"},
  {"step":345,"scope":"backend-e2e-tests","context":"Aplicație NestJS configurată; posibil Event Bus de test sau stub","task":"Implementează teste de integrare/E2E pentru scenarii cheie ale modulului Sales & Billing. Folosește Supertest sau Jest cu server NestJS real pornit pe un DB SQLite test. Scenariu: creează un client, creează 2 produse, plasează o comandă (POST /sales-orders), simulează eveniment WMS (apelezi direct o metodă internă sau inserezi manual factura) – alternativ, apelează POST /sales-orders/:id/invoice dacă disponibil, verifică că factura apare în GET /invoices și că evenimentul sales.invoice.issued a fost publicat (poți intercepta cu un spy EventBusClient). Apoi înregistrează plata (POST /payments) și verifică statusurile finale (comandă Paid, invoice Paid).","dirs":["/standalone/mercantiq/apps/sales/api/test/e2e/"],"constraints":"Rulează aceste teste în memorie, nu afecta environment-ul dev. Dacă event bus real nu poate fi folosit, mock-uiește-l dar asigură-te că logică eveniment este testată. Commit 'test(sales-api): e2e order-to-cash'.","output":"teste E2E backend trec (flux complet O2C simulat, evenimente verificate)"},
  {"step":346,"scope":"frontend-unit-tests","context":"UI Sales implementat (POS, Orders)","task":"Adaugă teste unitare pentru componentele frontend critice folosind Vitest + React Testing Library. Ex: testează componenta de **POS**: dacă adaugi produse simulate, calculează corect totalul și formatează suma; testează componenta de offline queue: când `navigator.onLine=false`, `OfflineOrderQueue.save()` este apelat. Testează de asemenea componenta de Orders list: cu props de comenzi, verifică randarea corectă a rândurilor și butonul de download vizibil doar pentru cele cu factură.","dirs":["/standalone/mercantiq/apps/sales/frontend/src/__tests__/"],"constraints":"Coverage minim 80% pe frontend. Simulează contexte necesare (ex: provider de tema MUI). Commit 'test(sales-ui): unit tests'.","output":"teste unitare UI verzi (coverage >80%, simulare contexte MUI)"},
  {"step":347,"scope":"frontend-e2e-tests","context":"Aplicație Sales deployabilă; Storybook/opțiuni UI test disponibile","task":"Implementează teste E2E pentru frontend (folosind Playwright). Scenariu: autentificare în aplicație (dacă necesar, altfel mocking token), navigare către modul Sales & Billing prin Shell, folosirea paginii POS: adaugă un produs, selectează client, apasă Submit și așteaptă confirmare vizuală (ex: mesaj "Order created"). Apoi navighează la pagina Orders și verifică apariția comenzii cu status corespunzător. (Optional: dacă ai un backend mock sau environment de test integrat, poți aștepta schimbarea statusului în 'Paid' după un timeout pentru a simula WMS+payment).","dirs":["/standalone/mercantiq/apps/sales/frontend-e2e/"],"constraints":"Headless browser pe CI. Folosește selectors stabili (data-test-id). Nu depinde de date specifice (seed-ul deja introdus). Commit 'test(sales-ui): e2e tests'.","output":"Playwright E2E Sales UI trece (scenariu POS complet, navigare Shell verificată)"},
  {"step":348,"scope":"docker-images","context":"Module implementat; necesar containerizare","task":"Construiește imagini Docker pentru componentele modulului Sales & Billing. Creează `Dockerfile.sales-api` (multi-stage: build NestJS → dist → runtime node:alpine, user non-root) și `Dockerfile.sales-ui` (build Vite → statics în Nginx, configurare Nginx pentru route fallback). Optimizează layer-ele pentru cache (ex: `npm ci` separat de build). Adaugă ambele Dockerfile-uri în directorul `/docker/`.","dirs":["/docker/"],"constraints":"Imaginile finale minimaliste (folosește `node:20-alpine` și `nginx:stable-alpine`). Setează variabile runtime necesare (ex: URL backend API pentru UI via env). Commit 'feat(ci): add Dockerfiles for sales'.","output":"imagini Docker Mercantiq Sales buildabile (multi-stage optimizate, user non-root)"},
  {"step":349,"scope":"helm-chart","context":"Infrastructura Kubernetes gata (F0); modul deploiement similar Admin Core","task":"Creează un chart Helm pentru Mercantiq Sales & Billing. În directorul `/standalone/mercantiq/infra/helm/mercantiq-sales/`, definește resursele Kubernetes: Deployment pentru API (include container sales-api + sidecar OTEL dacă folosește), Deployment pentru frontend (container Nginx cu staticile build-uite), Service pentru API (ClusterIP), IngressRoute (Traefik v2) pentru expunerea UI și API (ex: `sales.demo.company.com` cu path-uri /api și / pentru UI), obiecte ConfigMap/Secret necesare (ex: config API baseURL pentru UI, JWT public key secret montat la API).","dirs":["/standalone/mercantiq/infra/helm/mercantiq-sales/"],"constraints":"Include **ServiceMonitor** pentru API (endpoint de metrics). Utilizează variabile/valori separate pentru environment (dev/prod). Nu uita liveness/readiness probe-uri. Commit 'feat(helm): chart mercantiq-sales'.","output":"chart Helm Mercantiq Sales creat (deployment, service, ingress, probes configurat)"},
  {"step":350,"scope":"helm-hpa","context":"Chart Helm Mercantiq Sales creat (pas 349); cerințe scalare","task":"Adaugă configurații de autoscalare orizontală (HPA) în chart-ul Mercantiq Sales. Setează HPA pentru **API**: minReplicas 1, maxReplicas 5, target CPU 70% (similar Admin Core) și, dacă se dorește, HPA pentru frontend (de obicei nu, fiind static). Include și `ScaledObject` KEDA pentru procesarea backlog-ului de mesaje dacă modulul consumă direct cozi (ex: dacă ar exista coadă dedicată pentru evenimente, dar în acest caz RabbitMQ deliveră către microserviciu).","dirs":["/standalone/mercantiq/infra/helm/mercantiq-sales/templates/"],"constraints":"Metricile de bază (CPU) disponibile out-of-the-box. Dacă folosești KEDA, asigură-te că există metrice (RabbitMQ queue) și configurație corectă (ex: scale când >50 mesaje neprocesate pe `sales` queue).","output":"autoscaling configurat pentru modul Sales (HPA API 1-5 replicas, KEDA optional)"},
  {"step":351,"scope":"argocd-app","context":"Chart Helm publicat (pas 349) în registry OCI; cluster ArgoCD în place (F0)","task":"Definește o aplicație ArgoCD pentru Mercantiq Sales & Billing. Creează fișierul `mercantiq-sales.yaml` sub `/infra/k8s/argocd/apps/`, specificând sursa (chart OCI cu versiunea semver curentă, repository și path dacă e cazul) și destination (namespace corespunzător, ex: `mercantiq-sales`). Include sincronizare automată și strategie de upgrade (poate Canary dacă configurat global). Commite modificarea și verifică în UI-ul ArgoCD apariția noii aplicații.","dirs":["/infra/k8s/argocd/apps/"],"constraints":"Respectă formatul celorlalte definiții Argo (ex: Admin Core). Setează health checks (optional) și dependințe dacă e cazul (ex: să pornească după RabbitMQ operator, etc.). Commit 'feat(argocd): add mercantiq-sales app'.","output":"Mercantiq Sales & Billing urmărit de ArgoCD (aplicație sync automată configurată)"},
  {"step":352,"scope":"ci-cd-pipeline","context":"Workflows CI existente (F0) pentru build/test/scan; modul nou neintegrat","task":"Extinde pipeline-ul CI/CD pentru a include Mercantiq Sales & Billing. Adaugă în workflow (sau creează un nou `.github/workflows/mercantiq-sales.yml`) job-uri pentru: build imagini Docker (folosind Dockerfile-urile create la pas 348), scanare securitate container (Trivy cu severitate HIGH ca prag), push imagini în registry (ghcr sau ECR), generare și push chart Helm (package chart și push OCI), semnare artefacte container și chart cu **Cosign**. Asigură-te că la merge pe main pipeline-ul declanșează deployment (ArgoCD sync implicit se ocupă, dar poți adăuga notificări).","dirs":["/.github/workflows/"],"constraints":"Folosește Convenții commit (ex: 'ci(sales): ...'). Asigură variabile în secret (creds registry, cosign key). Include badge de coverage pentru modulul Sales în README dacă e cazul. Commit 'ci(sales): pipeline integration'.","output":"CI integrat pentru Mercantiq Sales (build/test/scan/deploy automat, Cosign signing)"},
  {"step":353,"scope":"supply-chain-security","context":"Imagini și chart produse în CI (pas 352)","task":"Activează măsuri suplimentare de securitate supply-chain pentru noul modul. Configurează generarea de SBOM (Software Bill of Materials) pentru imagini container (ex: folosind Syft) și include semnarea atestărilor **Cosign** (SBOM attestation în format SPDX) pentru imaginile Mercantiq Sales. Configurează politica de retenție a artefactelor din registru (păstrează ultimele N versiuni). Integrează verificarea semnăturilor în pipeline-ul de deploy (ArgoCD poate verifica semnătura chart-ului Helm).","dirs":["/.github/workflows/","/infra/policies/opa/"],"constraints":"Asigură-te că atestările sunt încărcate în registru (Cosign attaches to OCI ref). Dacă există OPA Gatekeeper, definește o politică ce interzice imagini ne-semnate (ex: `latest`).","output":"supply-chain fortificat (SBOM generat, attestări Cosign, politici OPA pentru imagini semnate)"},
  {"step":354,"scope":"otel-tracing","context":"Stack OpenTelemetry disponibil (Tempo collector), Admin Core are deja OTEL","task":"Activează **distributed tracing** în Mercantiq Sales API. Implementează inițializarea OpenTelemetry SDK la pornirea NestJS (ex: folosește `@nestjs/otel` sau manual `NodeTracerProvider`). Configurează exporter OTLP către Tempo (prin collector existent) și asigură ca toate request-urile HTTP, interacțiunile cu RabbitMQ și query-urile DB să fie instrumentate. Adaugă tag-ul de service `service.name=mercantiq-sales-api` pentru a diferenția in Grafana Tempo. Include propagarea contextului pentru evenimente (ex: inserează `traceparent` în header la publish event, dacă se aplică).","dirs":["/standalone/mercantiq/apps/sales/api/src/config/","/standalone/mercantiq/apps/sales/api/src/main.ts"],"constraints":"Nu impacta performanța semnificativ (sampler probabil 1:1 în dev, dar poate reduce la Prod). Verifică în Grafana Tempo că apar tranzacțiile de la Sales (ex: flux creare comandă).","output":"tracing distribuit activ pentru Mercantiq Sales API (vizibil în Tempo, propagare context)"},
  {"step":355,"scope":"prom-metrics","context":"Prometheus operator & servicemonitor deja configurate; API Sales expus","task":"Adaugă metrici Prometheus custom și standard în Mercantiq Sales API. Utilizează un middleware NestJS sau `@willsoto/nestjs-prometheus` pentru a exporta metrica HTTP (ex: număr de cereri, durata pe endpoint - histograme). Definește câteva metrici de business utile pentru dashboard O2C: ex. `sales_orders_total` (counter, increment la fiecare comandă nouă), `invoices_issued_total`, `payments_total`. Expune endpoint-ul `/metrics` al API-ului și verifică că ServiceMonitor-ul din chart scrappează datele.","dirs":["/standalone/mercantiq/apps/sales/api/src/","/standalone/mercantiq/apps/sales/api/src/config/"],"constraints":"Prefix metricile cu modul (ex: `mercantiq_sales_*` dacă sunt globale). Nu divulga date sensibile prin metrici. Test: vizualizează metricile în Prometheus (ex: `mercantiq_sales_sales_orders_total` crește).","output":"metrici Prometheus expuse (HTTP & business metrics: orders, invoices, payments)"},
  {"step":356,"scope":"grafana-dashboard","context":"Metrici colectate (pas 355); nevoie vizibilitate flux O2C","task":"Creează un **dashboard Grafana** centrat pe fluxul Order-to-Cash (O2C) pentru modulul Sales & Billing. Include panouri precum: număr de comenzi noi vs. facturi emise vs. plăți (cu sursă metricile `*_total` definite), durata medie de la comandă la factură (dacă se poate deduce – ex. prin diferența timestamp între events, poate fi necesar un PromQL pe evenimente dacă stochezi timestamp în metrici), rata de eroare API (metrică HTTP 5xx), backlog mesaje RabbitMQ relevante (ex: coada pdf.render dacă se poate, metrică din exporter RMQ). Aranjează panourile și adaugă anotări de eveniment dacă posibil (ex: deploy-uri). Salvează dashboard-ul în repo (JSON).","dirs":["/infra/grafana/provisioning/dashboards/"],"constraints":"Respectă convențiile de naming (UID dashboard unic, ex: `O2C_sales_dashboard`). Testează dashboard-ul cu datele demo (simulează câteva comenzi și plăți să vezi graficele populând).","output":"Dashboard Grafana Order-to-Cash disponibil (flux O2C vizibil: orders→invoices→payments)"},
  {"step":357,"scope":"alerting-rules","context":"SLO definite (latency p95, error rate); Alertmanager configurat (F0)","task":"Configurează alerte automate pentru modul Sales & Billing în conformitate cu SLO și fiabilitate. Creează un fișier de reguli Alertmanager (sau adaugă în cel existent) cu următoarele: alertă **HighErrorRateSales** – se declanșează dacă rata de erori 5xx a API-ului Sales depășește 1% pe interval de 5m; alertă **SlowResponseSales** – dacă latența p95 a endpoint-urilor Sales > 250ms timp de 5m; alertă **QueueBacklogSales** – dacă numărul de mesaje neprocesate pe coada RabbitMQ (ex: pdf.render sau tax.vat) depășește un prag (ex: >50) sau dacă un mesaj stă în coadă >30s. Setează notificarea acestor alerte către canalul potrivit (email/Slack).","dirs":["/infra/k8s/alertmanager/","/infra/prometheus/rules/"],"constraints":"Test manual al regulilor: provoacă un 500 intenționat și vezi dacă se alertează în Prometheus Alert UI. Folosește severitate adecvată (warning vs critical) pentru praguri. Commit 'feat(alerts): add sales SLO alerting'.","output":"reguli de alertă SLO pentru Sales implementate (error rate >1%, latency p95 >250ms, queue backlog)"},
  {"step":358,"scope":"admin-nav-integration","context":"Modul nou Mercantiq Sales; Shell gateway afișează meniu din Admin Core","task":"Integrează modulul Sales & Billing în navigația principală a aplicației. În Admin Core (sau Shell, în funcție de implementare), adaugă o intrare nouă în structura de navigație: titlu \"Sales & Billing\", icon dacă este disponibil (ex: icoană factură), și configurarea necesară pentru a încărca micro-front-end-ul Sales. De exemplu, dacă Admin Core expune un endpoint `/v1/admin/nav`, extinde răspunsul JSON cu ceva de genul: `{ name: 'Sales & Billing', path: '/sales', module: 'mercantiq_sales', entry: '/remoteEntry.js' }` (conform modului de încărcare remote). Ajustează și permisiunile de acces – ex: doar utilizatorii cu roluri sales pot vedea acest meniu.","dirs":["/core/apps/admin-core/api/src/controllers/","/core/apps/admin-core/api/src/services/"],"constraints":"Păstrează același format ca celelalte intrări. Verifică după deploy că în UI Shell apare noua secțiune de meniu și că la click se încarcă remote-ul Mercantiq Sales (widget-urile/ paginile sale).","output":"Mercantiq Sales & Billing integrat în meniul principal (navigație Shell funcțională, permisiuni RBAC)"},
  {"step":359,"scope":"handover-f2-check","context":"Toate componentele F2 implementate (CRM, Sales, Procurement, WMS)","task":"Pregătește predarea Fazei F2. Compilează documentația relevantă: diagrame actualizate (ERD Sales, diagrame sequence O2C), colecții Postman pentru API-urile Sales & Billing, link către dashboard-ul O2C creat (pas 356). Asigură existența fișierului `F2_handover.md` în docs, care sumarizează livrabilele F2 (incluzând Mercantiq Sales). Rulează scriptul `scripts/gate-f2.sh` pentru a valida automat criteriile de Gate: creează o comandă E2E pe un tenant demo și verifică că evenimentele `sales.order.created` -> `wms.picklist.completed` -> `sales.invoice.issued` -> `tax.vat.validated` -> `pdf.render.done` -> `payment.received` apar în succesiune și că alerta de succes O2C este verde.","dirs":["/docs/","/scripts/"],"constraints":"Orice criteriu eșuat oprește pipeline-ul (Gate not passed). Include screenshot-uri/link-uri în documentația de predare. Aprobare formală necesară înainte de a continua la Faza F3.","output":"Gate F2 trecut – Mercantiq Sales & Billing livrat cu succes (flux O2C E2E validat, documentație completă)"}
]
```

---

## 9) Note de implementare

* **Căi canonice & arbore directoare**: folosește exact structura indicată pentru standalone apps (`standalone/mercantiq/apps/sales/`); nu devia la `/apps` fără prefix `standalone/`.
* **Evenimente & naming**: menține convențiile v1 și validează în CI cu `lint-rmq.sh`. Format: `sales.order.created`, `sales.invoice.issued`, `payment.received`.
* **Workers**: integrează-te cu workers existenți (`pdf.render`, `tax.vat`, `notify.slack`) fără a schimba stack-ul lor (Python 3.13 + Celery/Ray).
* **Multitenancy/RLS**: izolare strictă `tid/whid/mid` conform modelului de date Fasei F2.
* **POS Offline**: implementarea offline trebuie să fie robustă cu IndexedDB și sync automat la reconectare.
* **Order-to-Cash**: fluxul complet trebuie validat E2E cu toate evenimentele în succesiune.
* **Conformitate ANAF**: integrarea cu `tax.vat` worker pentru e-Factură este obligatorie.
* **CI/CD**: Trivy HIGH, cosign sign/attest, Argo sync, canary + rollback metric-based conform umbrelei F2.
